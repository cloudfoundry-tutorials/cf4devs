[
  {
    "url": "/korifi/overview/",
    "title": "An Overview of the Korifi Project",
    "description": "In this introductory section, learn how Korifi simplifies the deployment and management of applications on Kubernetes.",
    "content": "Kubernetes alone does not provide a high-productivity development platform for building and running modern applications. Even as the cloud-native community addresses application platform concerns through related projects, it is still complicated to bring them together into a cohesive platform. Korifi\u0026rsquo;s purpose is to deliver an inherently higher-order abstraction over Kubernetes, ultimately enabling developers to focus on building applications and simplifying the operations process.\nThe Cloud Foundry community is building Korifi to meet the need for internal development platforms on Kubernetes. It is purpose-built to serve as a means to deploy applications while providing automated networking, security, availability, and much more. The principal value of Cloud Foundry continues to be its first-class, multi-tenant, self-service experience for app developers, including not only running app workloads but also building and maintaining the app artifacts, exposing those apps to their end users, and provisioning and connecting dependencies (services) for those apps.\nWith Korifi, software engineering teams can establish a comprehensive Kubernetes strategy and adopt best practices across the development, testing, and deployment phases.\nKorifi vs. Cloud Foundry with BOSH Korifi shares the same principal goal of Cloud Foundry: to delight developers and operators with a highly efficient, modern model for cloud-native application delivery and management. However, Korifi is very different architecturally from traditional Cloud Foundry.\nTraditional Cloud Foundry is deployed via BOSH, on virtual machines, using infrastructure-as-a-service providers like VMWare or AWS. The core components of conventional Cloud Foundry are implemented in custom code and run as processes on virtual machines.\nKorifi is a new approach to implementing the Cloud Foundry APIs on Kubernetes. Most of the core Cloud Foundry components have been replaced by implementations using Kubernetes native equivalents. Custom code implementation is a last resort.\nApproach The Korifi project adopts an entirely new approach to implementing the proven capabilities of the Cloud Foundry API. As Korifi continues to grow and evolve, the intention is to continue embracing the best solutions the Kubernetes ecosystem offers.\nGuiding Principles The Korifi project is guided by the following principles:\nKorifi should integrate with projects and technologies from Kubernetes and other cloud-native ecosystems as replacements for custom Cloud Foundry subsystems where these ecosystem projects have demonstrated widespread adoption and operational maturity.\nConversely, Korifi should retain Cloud Foundry-specific concepts where there is no clear or dominant replacement coming from cloud-native ecosystems but should prepare to replace them in the future.\nThe control plane components of Korifi should interact with the subsystems through defined interfaces that allows for introducing alternative technologies from other ecosystems.\nThe community reference deployment (which you will install next) should be optimized for initial, lightweight usage and experimentation.\nThe default developer-facing behavior of Korifi should strive to match that of Cloud Foundry today while providing the ability to opt into different behavior using alternative subsystems.\nThe Cloud Foundry API entities should have an analogous representation in the Kubernetes API, and Korifi should eventually allow users to manipulate either representation.\nThrough the rest of this material, we detail the Kubernetes ecosystem components currently in use and the custom resources defined by Korifi.\nArchitectural Subsystems From an architectural perspective, we want to retain the CF developer experience and developer-facing API but implemented in terms of operator-facing interfaces for the following subsystems (in priority order):\nNetworking and Connectivity, including ingress routing, application service mesh, and network security policies Identity, Authentication, and Authorization, including CF user roles and resource ownership Workload Orchestration, including running CF app processes and tasks or the ability to schedule workloads on one or more separate Kubernetes clusters Artifact Building, including creating and updating app images and storing them in registries Observability, including app logging, monitoring, and request tracing Service Marketplace, including registering and exposing service plans to tenants, provisioning services, and binding them to workloads Each of these interfaces will have one or more backing implementations, coming either from the Kubernetes ecosystem or the Cloud Foundry community.\nCloud Foundry Capabilities Korifi continues to support core Cloud Foundry capabilities:\nMulti-cloud: Korifi is deployed using Helm and supports multiple public and private cloud providers. Korifi is lightweight and can even run workloads at the edge.\nMulti-tenant: Korifi utilizes Kubernetes role-based access control and custom resource definitions to mimic the robust Cloud Foundry paradigm of orgs, spaces, users and roles. Together, the two provide a foundation for multi-tenancy that is resilient and secure.\nAny language, any framework: Korifi preserves the classic Cloud Foundry experience of being able to deploy apps written in any language or framework with a single cf push command. It enhances the app developer experience by using Paketo buildpacks to build applications as OCI-compliant containers. App developers no longer have to wrangle with complex YAML or Dockerfiles for containerized deployments to Kubernetes.\nRoadmap From the Vision for CF on Kubernetes document:\n\u0026ldquo;We envision a Cloud Foundry on Kubernetes (CF on K8s) that provides the same convenient developer outcomes that Cloud Foundry delivers today via BOSH, and that enables these developers to migrate their workloads smoothly from their existing CF environments to CF on K8s. While an ideal outcome for current CF users would be to preserve complete compatibility with existing behavior and to provide a completely transparent migration of running app workloads within existing environments, we also see opportunities to deliver pragmatic solutions sooner at the expense of complete compatibility or transparency.\u0026rdquo;\nThe Korifi project aims to bring the best developer and operator experiences to Kubernetes. The team continues to work hard implementing and evolving additional Cloud Foundry APIs.\n"
  },
  {
    "url": "/korifi/local-install/",
    "title": "Installing Korifi locally",
    "description": "Korifi is lightweight and easy to deploy. Experience the power and simplicity of Korifi by installing it locally on Kubernetes using Kind.",
    "content": "In this exercise, you will install Korifi locally on kind using a locally deployed container registry. To install Korifi on another Kubernetes provider, see the installation documentation in GitHub.\nPrerequisites You will need the following prerequisites to use Korifi locally. If you are a Kubernetes user, you likely already have most of these tools installed.\nFollow the instructions below to install the prerequisites.\nDocker Desktop: Kind uses Docker to run Kubernetes container nodes. Install Docker Desktop according to the instructions.\nkind: kind is a tool for running local Kubernetes clusters using Docker container “nodes”. Install kind by following the directions. You only need to install kind; you do not need to create a cluster yet.\nHelm: Helm is a package manager for Kubernetes. Helm is used to install Korifi on a Kubernetes cluster. Install Helm according to the instructions.\nkubectl: kubectl is the the Kubernetes command-line tool, allowing you to run commands against Kubernetes clusters. Install kubectl according to the instructions.\ncf: cf is the Cloud Foundry command-line tool. Install the latest version of the Cloud Foundry CLI according to the instructions.\nkbld: kbld builds and copies the required docker images to the local registry. Install the latest version of kbld according to the instructions.\nInstallation Overview The Korifi development team maintains an installation script to install Korifi locally. It installs the Kubernetes ecosystem dependencies outlined below and a local container registry. We will use this script to install Korifi. If you prefer, you can follow the installation instructions on GitHub to install Korifi manually.\nThe install script does the following before installing Korifi:\nCreates a kind cluster with the correct port mappings for Korifi and other components. Deploys a local Docker registry using the twuni helm chart. Creates an admin user for Cloud Foundry. Installs cert-manager. cert-manager is used to create and manage internal certificates within the cluster. Installs kpack. kpack is used to build runnable applications from source code using Cloud Native Buildpacks. Installs contour. Contour is the ingress controller for Korifi. Installs the service binding runtime which is an implementation of the service binding spec. Install the metrics server Installing Korifi While you can install all of the above manually, it is far easier to use the deploy-on-kind.sh script in the Korifi repository.\nPlease note the Korifi development team uses this script for local development. It is not intended for production use. At times the script may change or break.\nTo install Korifi:\nClone the Korifi repository locally: git clone https://github.com/cloudfoundry/korifi\nChange to the scripts directory: cd korifi/scripts\nInstall Korifi using the deploy-on-kind.sh script: ./deploy-on-kind.sh korifi\nNote, the name \u0026lsquo;korifi\u0026rsquo; above is the name of the cluster created in kind. You can use any name you would like.\nDeploying an Application We have provided a sample application you can deploy to your Korifi instance. However, before deploying, we need to set up our Cloud Foundry instance a bit by doing the following:\nTarget the Cloud Foundry instance: cf api localhost --skip-ssl-validation Authenticate: cf auth cf-admin Create an Org: cf create-org tutorial Create a Space: cf create-space -o tutorial dev Target the Org and Space you created: cf target -o tutorial -s dev Now you are ready to deploy the application:\nClone the sample application: git clone https://github.com/cloudfoundry-tutorials/korifi-sample-app.git Change the application directory: cd korifi-sample-app Deploy the application: cf push At a high level, the following happens:\nThe cf command line interface uploads the application bits Korifi uses kpack and Paketo buildpacks to build a container image for the application The container image is stored in the local Docker registry The container image is deployed to Kubernetes Ingress traffic will be mapped to the application using Contour You will see an output that ends with something similar to the following. If you copy the route, you should be able to open the application in a browser.\nrequested state: started\rroutes: sample-app.apps-127-0-0-1.nip.io\rlast uploaded: Thu 09 Feb 11:02:52 MST 2023\rstack: io.buildpacks.stacks.bionic\rbuildpacks: type: web\rsidecars: instances: 1/1\rmemory usage: 32M\rstart command: sh \u0026#34;/workspace/start.sh\u0026#34;\rstate since cpu memory disk logging details\r#0 running 2023-02-09T18:03:43Z 0.0% 0 of 0 0 of 0 0/s of 0/s In the next section, we will look at Korifi and the deployed application using kubectl.\n"
  },
  {
    "url": "/korifi/k8s/",
    "title": "Korifi for K8s Users",
    "description": "Are you already a Kubernetes user? Learn how Korifi can simplify the deployment and management of applications on Kubernetes.",
    "content": "As we have stated, Korifi is an implementation on top of Kubernetes. Because of this, you can view Korifi resources either at the higher level (application-centric) abstraction using the cf CLI or at the lower level (container-centric) using kubectl. However, because the use of kubectl is not required to use Korifi, we will not go in-depth on the use of kubectl with Korifi elements.\nKorifi with kubectl You can use kubectl to view and interact with the underlying Korifi components. However, kubectl is optional as the entire lifecycle of applications can be managed using the cf CLI. However, we will touch on the basics below. We leave the detailed investigation to you should you choose to embark on it.\nNamespaces The Korifi installation creates multiple namespaces. You can view the namespaces created by Korifi (denoted below with a \u0026ldquo;*\u0026rdquo;).\nkubectl get namespaces\rcert-manager* Active 25h\rcf* Active 25h\rcf-org-d255d9f0-962e-4122-bd6a-422110b15e0d* Active 117m\rcf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f* Active 116m\rdefault Active 25h\rkorifi* Active 25h\rkpack* Active 25h\rkube-node-lease Active 25h\rkube-public Active 25h\rkube-system Active 25h\rlocal-path-storage Active 25h\rprojectcontour* Active 25h\rservicebinding-system* Active 25h Application Pods Of note are the namespaces starting with cf-org-* and cf-space-*. These correspond to the org and space created after the installation. Applications are deployed to a space. Therefore, you can view your application pods in the namespace corresponding to your space:\nkubectl get pods -n cf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f\rNAME READY STATUS RESTARTS AGE\rd60fe7b7-f080-4caa-a26b-b811c88d766e-cf--cbc52994d8-1 1/1 Running 0 16h\ref3d386d-1cea-46bf-8191-fedcedba8532-build-1-build-pod 0/1 Completed 0 17h The pod marked \u0026ldquo;Completed\u0026rdquo; was used during your application\u0026rsquo;s build process (called staging).\nCustom Resources As discussed earlier, Korifi uses custom resource definitions to implement Cloud Foundry constructs. You can view the list of custom resources created by Korifi.\nkubectl api-resources | grep korifi\rappworkloads korifi.cloudfoundry.org/v1alpha1 true AppWorkload\rbuilderinfos korifi.cloudfoundry.org/v1alpha1 true BuilderInfo\rbuildworkloads korifi.cloudfoundry.org/v1alpha1 true BuildWorkload\rcfapps korifi.cloudfoundry.org/v1alpha1 true CFApp\rcfbuilds korifi.cloudfoundry.org/v1alpha1 true CFBuild\rcfdomains korifi.cloudfoundry.org/v1alpha1 true CFDomain\rcforgs korifi.cloudfoundry.org/v1alpha1 true CFOrg\rcfpackages korifi.cloudfoundry.org/v1alpha1 true CFPackage\rcfprocesses korifi.cloudfoundry.org/v1alpha1 true CFProcess\rcfroutes korifi.cloudfoundry.org/v1alpha1 true CFRoute\rcfservicebindings korifi.cloudfoundry.org/v1alpha1 true CFServiceBinding\rcfserviceinstances korifi.cloudfoundry.org/v1alpha1 true CFServiceInstance\rcfspaces korifi.cloudfoundry.org/v1alpha1 true CFSpace\rcftasks korifi.cloudfoundry.org/v1alpha1 true CFTask\rtaskworkloads korifi.cloudfoundry.org/v1alpha1 true TaskWorkload You can explore these resources using kubectl or view the representations defined in the Korifi API.\nHow do I\u0026hellip;? In Korifi, the primary unit of focus is the application. An application is a higher-level abstraction than a container. Korifi allows developers to work at the higher level but still drop down to the lower level abstraction if need be. Below, we answer common questions from Kubernetes users.\nHow do I run a container image? With Korifi, you do not need to bring a container image. Instead, you bring your application code (uploaded during the cf push). Korifi will use kpack and Paketo buildpacks to construct an OCI compatible container image for your application.\nPaketo is an implementation of Cloud Native Buildpacks, an easier, more streamlined, secure, and repeatable way to build container images. Cloud Native Buildpacks are part of the Cloud Native Computing Foundation and are supported by all major cloud providers. So while Korifi ships with the Paketo implementation, you can use other provider implementations as well.\nHow do I check on my pods? With Korifi, applications run in pods. You do not need to create pods yourself. However, you can still run non-cf pods in the same Kubernetes instance.\nAn application is a higher-level construct in Korifi. Therefore you can check on your applications using the cf CLI. For example, you can see your apps (in an org and space) by running cf apps. If you deployed the sample application, you would see a list of your applications similar to:\nGetting apps in org tutorial / space dev as cf-admin...\rname requested state processes routes\rsample-app started web:1/1 sample-app.apps-127-0-0-1.nip.io You can also see more details about your app with cf app \u0026lt;APP_NAME\u0026gt;:\ncf app sample-app\rShowing health and status for app sample-app in org tutorial / space dev as cf-admin...\rname: sample-app\rrequested state: started\rroutes: sample-app.apps-127-0-0-1.nip.io\rlast uploaded: Thu 09 Feb 16:34:02 MST 2023\rstack: io.buildpacks.stacks.bionic\rbuildpacks:\rtype: web\rsidecars:\rinstances: 1/1\rmemory usage: 32M\rstate since cpu memory disk logging details\r#0 running 2023-02-10T00:23:19Z 0.0% 22.1M of 32M 0 of 64M 0/s of 0/s The depths of the Cloud Foundry API are outside the scope of this tutorial. However, we recommend you peruse the documentation and the features in the cf CLI. You will notice that you have access to all the same Kubernetes primitives and the higher-level resource definitions.\nHow do I configure my application to handle more traffic? In Korifi, you can scale your application using cf scale to add instances (horizontal scale) or memory (vertical scale). Korifi will handle the rest. You do not need to update any other configuration.\nHow do I allow traffic into my application? By default, applications are deployed with an assigned route. This route is used to access the application. Korifi manages the ingress routing for you. You can also deploy applications without a route if ingress is not required.\nHow do I create a load balancer between pods? You don\u0026rsquo;t need to. Instead, as you add (or remove) instances with the cf scale command, Korifi handles this for you.\nHow do I restart apps/pods/containers? You likely won\u0026rsquo;t need to in most cases. However, if you want to, you can use the cf start, cf stop, and cf restart commands.\nHow to update the application to a new version? You can simply re-run the cf push command when you have a new version of your application.\nHow can I create isolation between projects? You can use the Cloud Foundry constructs of Orgs and Spaces. Orgs and spaces are implemented using namespaces in Korifi. Users are assigned Cloud Foundry roles in orgs and spaces to control access using Kubernetes RBAC. Using the Korifi constructs is far simpler than directly managing namespaces and Kubernetes RBAC.\n"
  },
  {
    "url": "/korifi/cf/",
    "title": "Korifi for CF Users",
    "description": "Are you a Cloud Foundry user? Learn how Korifi extends Kubernetes to bring a Cloud Foundry-like experience to the industry-leading container orchestration platform.",
    "content": "If you are an existing Cloud Foundry user, your experience with Korifi will be pretty familiar. However, the underlying implementations of the Cloud Foundry API are quite different. This section focuses on the underlying Kubernetes representations of common Cloud Foundry constructs.\nAdditionally, Korifi only supports a subset of the Cloud Foundry API. The currently supported endpoints are documented in the Korifi API documentation.\nHow are orgs, spaces, and roles implemented? Orgs and spaces are implemented using namespaces. Roles are implemented using Kubernetes RBAC.\nOrgs and spaces will each have their own corresponding namespace. The name corresponds to the GUID of the org/space.\nkubectl get namespaces\rNAME STATUS AGE\r... Active 47h\rcf-org-d255d9f0-962e-4122-bd6a-422110b15e0d Active 23h\rcf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f Active 23h\r... Fetching the GUID for the org:\ncf org --guid tutorial\rcf-org-d255d9f0-962e-4122-bd6a-422110b15e0d Fetching the GUID for the space:\ncf space --guid dev\rcf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f Roles are mapped to a RoleBinding of a ClusterRole object:\nkubectl get rolebindings -n cf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f\rNAME ROLE AGE\rcf-8d87de46bc2d38fe0c96aa24cd3191d7d4528ca101b07ecbd9d3ef3fecb53de5 ClusterRole/korifi-controllers-space-developer 23h\rcf-dc43e0e171a16401f2a495e6d38f32434a2958dd430aa6ffe792d2491e4a361e ClusterRole/korifi-controllers-space-manager 23h\rdefault-admin-binding ClusterRole/korifi-controllers-admin 23h What does an app look like? Application instances are pods in a namespace corresponding to the space. CFApp is a custom resource definition.\nTo view this information using kubectl, you must first fetch the space GUID to determine the namespace name.\ncf space --guid dev\rcf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f You can then use kubectl to view the details. For example, in the below block, there is one pod for each instance (two are running). And the pod marked \u0026ldquo;Completed\u0026rdquo; was used during staging.\nkubectl get pods -n cf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f\rNAME READY STATUS RESTARTS AGE\rd60fe7b7-f080-4caa-a26b-b811c88d766e-cf--cbc52994d8-0 1/1 Running 0 17h\rd60fe7b7-f080-4caa-a26b-b811c88d766e-cf--cbc52994d8-1 1/1 Running 0 16h\ref3d386d-1cea-46bf-8191-fedcedba8532-build-1-build-pod 0/1 Completed 0 17h To view the custom resource:\nkubectl get cfapp -n cf-space-0eee9ef7-ff1e-4a80-842f-a53179768b6f\rNAME DISPLAY NAME AGE\rd60fe7b7-f080-4caa-a26b-b811c88d766e sample-app 17h Cloud Foundry Resource Mappings If you would like a more complete picture of Cloud Foundry resources in Korifi refer to the table of Cloud Foundry to Kubernetes resource mappings. There are plenty of other resources to dive into, should you choose. However, if you are a Cloud Foundry user, you likely don\u0026rsquo;t care too much about the underlying implementations. Happy pushing!\n"
  },
  {
    "url": "/korifi/",
    "title": "Korifi by Cloud Foundry",
    "description": "",
    "content": ""
  },
  {
    "url": "/korifi/categories/",
    "title": "Categories",
    "description": "",
    "content": ""
  },
  {
    "url": "/korifi/tags/",
    "title": "Tags",
    "description": "",
    "content": ""
  }]